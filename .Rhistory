}
}
data[ ordered(data$Date), ]
}
# Chunk 5
getSymbols("T", src = "yahoo", from = "1985-01-01", to = "2015-12-31")
getSymbols("VZ", src = "yahoo", from = "1985-01-01", to = "2015-12-31")
# Chunk 6
chartSeries(T)
chartSeries(VZ)
# Chunk 7
ATT_adj = T$T.Adjusted; VER_adj <- VZ$VZ.Adjusted
# Chunk 8
combineStocks <-
function(lseries, rseries,
stockNames = c(deparse(substitute((a)),
deparse(substitute(b)))),
add_ratio = T) {
l_adj <- lseries[, 6]; r_adj <- rseries[, 6]
combined <- merge(l_adj, r_adj)
df_result <- structure(data.table(Date = index(combined), combined),
names = c("Date", stockNames))
if(add_ratio) {
Ratio <- combined[, 1] / combined[, 2]
df_result <- cbind(df_result, Ratio)
colnames(df_result)[4] <- "Ratio"
}
df_result
}
# Chunk 9
overlap <- combineStocks(T, VZ, c("ATT", "VER"))
names(overlap)
range(overlap$Date)
# Chunk 10
plotRatio <-
function(r, k = 1, date = seq(along = r), ...)
{
plot(date, r, type = "l", ...)
mu <- mean(r); kval <- k * sd(r)
upper <- mu + kval; lower <- mu - kval
abline(h = c(mu,
upper,
lower),
col = c("darkgreen", rep("red", 2 * length(k))),
lty = "dashed")
text(1, upper, upper)
}
plotRatio(overlap$Ratio, k = .85,
overlap$Date, col = "lightgray",
xlab = "Date", ylab = "Ratio")
findNextPosition <-
# e.g., findNextPosition(r)
#     findNextPosition(r, 1774)
# Check they are increasing and correctly offset
function(ratio, startDay = 1, k = 1,
m = mean(ratio), s = sd(ratio))
{
up = m + k * s
down = m - k * s
if(startDay > 1)
ratio <- ratio[ - (1:(startDay-1))]
isExtreme <- ratio >= up | ratio <= down
if(!any(isExtreme))
return(integer())
start = which(isExtreme)[1]
backToNormal <- if(ratio[start] > up)
ratio[ - (1:start) ] <= m
else
ratio[ - (1:start) ] >= m
# return either the end of the position or the index
# of the end of the vector
# could return NA for not ended, i.e,, which(backToNormal)[1]
# for both cases. But then the caller has to interpret that.
end <- if(any(backToNormal))
which(backToNormal)[1] + start
else
length(ratio)
c(start, end) + startDay + 1
}
k <- .85
a <- findNextPosition(r, k = k)
a <- findNextPosition(overlap$Ratio, k = k)
a
b <- findNextPosition(r, a[2], k = k)
b
b <- findNextPosition(r, a[2], k = k)
k <- .85
a <- findNextPosition(overlap$Ratio, k = k)
r <- overlap$Ratio; k <- .85
a <- findNextPosition(r, k = k)
b <- findNextPosition(r, a[2], k = k)
b
c <- findNextPosition(r, b[2], k = k)
showPosition <-
function(days, ratios, radius = 100) {
symbols(days, ratios, circles = rep(radious, 2),
fg = c("darkgreen", "red"), add = T, inches = F)
}
showPosition <-
function(pos, col = c("darkgreen", "red"), ...)
{
if(!is.list(pos))
return(invisible(lapply(pos, showPosition, col = col, ...)))
abline(v = pos, col = col, ...)
}
plotRatio(r, k, overlap$Date, xlab = "Date", ylab = "Ratio")
showPosition(overlap$Date[a], r[a])
plotRatio(r, k, overlap$Date, xlab = "Date", ylab = "Ratio")
showPosition(overlap$Date[a], r[a])
overlap$Date[a]
[a]
r[a]
showPosition(overlap$Date[a], r[a])
showPosition <-
function(days, ratios, radius = 100) {
symbols(days, ratios, circles = rep(radious, 2),
fg = c("darkgreen", "red"), add = T, inches = F)
}
showPosition(overlap$Date[a], r[a])
showPosition <-
function(days, ratios, radius = 100) {
symbols(days, ratios, circles = rep(radius, 2),
fg = c("darkgreen", "red"), add = T, inches = F)
}
plotRatio(r, k, overlap$Date, xlab = "Date", ylab = "Ratio")
showPosition(overlap$Date[a], r[a])
showPosition(overlap$Date[b], r[b])
showPosition(overlap$Date[c], r[c])
plotRatio(r, k, overlap$Date, xlab = "Date", ylab = "Ratio")
showPosition(overlap$Date[a], r[a])
showPosition(overlap$Date[b], r[b])
showPosition(overlap$Date[c], r[c])
getPositions <-
function(ratio, k = 1, m = mean(ratio), s = sd(ratio))
{
when = list()
cur = l
while(cur < length(ratio)) {
tmp <- findNextPosition(ratio, cur, k, m, s)
if(length(tmp) == 0)
break
when[[length(when) + 1]] <- tmp
if(is.na(tmp[2] || temp[2] == length(ratio)))
break
cur = tmp[2]
}
when
}
pos <- getPositions(r, k)
plotRatio(r, k, overlap$Date, xlab = "Date", ylab = "Ratio")
invisible(lapply(pos, function(p)
showPosition(overlap$Date[p], r[p])))
invisible(lapply(pos, function(p)
showPosition(overlap$Date[p], r[p])))
pos <- getPositions(r, k)
getPositions <-
function(ratio, k = 1, m = mean(ratio), s = sd(ratio))
{
when = list()
cur = 1
while(cur < length(ratio)) {
tmp <- findNextPosition(ratio, cur, k, m, s)
if(length(tmp) == 0)
break
when[[length(when) + 1]] <- tmp
if(is.na(tmp[2] || temp[2] == length(ratio)))
break
cur = tmp[2]
}
when
}
pos <- getPositions(r, k)
plotRatio(r, k, overlap$Date, xlab = "Date", ylab = "Ratio")
invisible(lapply(pos, function(p)
showPosition(overlap$Date[p], r[p])))
showPosition <-
function(days, ratio, radius = 70)
{
if(is.list(days))
days <- unlist(days)
symbols(days, ratio[days],
circles = rep(radius, length(days)),
fg = c("darkgreen", "red"),
add = T, inches = F)
}
k <- .5
pos <- getPositions(r, k)
k <- .5
pos <- getPositions(r, k)
plotRatio(r, k, col = "lightgray", ylab = "ratio")
showPosition(pos, r)
positionProfit <-
# r = overlap$att / overlap$verizon
# k = 1.7
# pos = getPositions(r, k)
# positionProfile(pos[[1]], overlap$att, overlap$verizon)
function(pos, stockPriceA, stockPriceB,
ratioMean = mean(stockPriceA / stockPriceB ),
p = 0.001, byStock = F)
{
if(is.list(pos)) {
ans = sapply(pos, positionProfit,
stockPriceA, stockPriceB, ratioMean, p, byStock)
if(byStock)
rownames(ans) <- c("A", "B", "commission")
return(ans)
}
# prices at the start and end of the positions
priceA <- stockPriceA[pos]
priceB <- stockPriceB[pos]
# how many units can we by of A and B with $1?
unitsOfA <- 1/priceA[1]
unitsOfB <- 1/priceB[1]
# The dollar amount of how many units we would buy of A and B
# at the cost at the end of the position of each
amt <- c(unitsOfA * priceA[2], unitsOfB * priceB[2])
# which are we selling
sellWhat <- if(priceA[1] / priceB[1] > ratioMean) "A" else "B"
profit <- if(sellWhat == "A")
c( ( 1 - amt[1]), (amt[2] - 1), - p * sum(amt))
else
c( (1 - amt[2]), (amt[1] - 1), - p * sum(amt))
if( byStock )
profit
else
sum(profit)
}
pf <- positionProfit(c(1, 2), c(3838.48, 8712.87),
c(459.11, 1100.65), p = 0)
pf
prof <- positionProfit(pos, overlap$ATT, overlap$VER, mean(r))
prof
i <- 1:floor(nrow(overlap)/2)
i <- 1:floor(nrow(overlap)/2)
train <- overlap[i, ]
test <- overlap[ -i, ]
r.train <- ratio[train]
ratio
r.train <- train$Ratio
r.train
r.test <- test$Ratio
train_period <- seq(min(overlap$Date), by = "5 years", length = 2)
train.period <- seq(min(overlap$Date), by = "5 years", length = 2)
rm(train_period)
train.period
att.train <- ATT[train.period]
att.train <- T[train.period]
att.train
train.period <- seq(min(overlap$Date), by = "5 years")
train.period
train.period <- seq(min(overlap$Date), by = "5 years", length.out = 2)
att.train <- subset(T, Date >= train.period[1])
att.train
att.train <- subset(T,  train.period[1])
att.train <- T[paste(train.period, sep = "::")]
att.train
att.train <- T[paste(train.period, sep = "/")]
att.train
T
paste(train.period, sep = "/")
paste(train.period, sep = "/")
paste0(train.period, sep = "/")
train.period
paste(train.period, sep = "/")
cat(train.period, sep = "/")
toString(train.period)
cat(toString(train.period), sep = "/")
cat(toString(train.period), delim = "/")
cat(toString(train.period))
paste(toString(train.period))
paste(toString(train.period), sep="/")
train.period <- seq(min(overlap$Date), by = "5 years", length.out = 2)
train.period
toString(train.period)
paste(train.period, sep="/")
paste(train.period, sep="/")
train.period <- seq(min(overlap$Date), by = "5 years", length.out = 2)
paste(train.period, sep="/")
cat(train.period, sep="/")
typeof(train[1])
cat(unlist(train.period), sep="/")
unlist(train.period)
paste(unlist(train.period), sep="/")
cat(unlist(train.period), sep="/")
as.Date(cat(unlist(train.period), sep="/"))
cat(unlist(train.period), sep="/")
train.period <- unlist(seq(min(overlap$Date), by = "5 years", length.out = 2))
typeof(train.period[1])
train.period
paste(train.period)
train.period <- unlist(seq(min(overlap$Date), by = "5 years", by = 60))
train.period <- unlist(seq(min(overlap$Date), by = "5 years"))
train.period <- seq(min(overlap$Date), by = "5 years")
train.period <- seq(min(overlap$Date), by = "5 years", length = 2)
train.period
paste(train.period[1], train.period[2], sep="/")
period.range <- paste(train.period[1], train.period[2], sep="/")
att.train <- T[period.range]
att.train
verizon.train <- VZ[period.range]$VZ.Adjusted
att.train <- T[period.range]$T.Adjusted
verizon.train <- VZ[period.range]$VZ.Adjusted
r.train <- att.train/verizon.train
max(overlap$Date)
test.period <- paste(train.period[2], max(overlap$Date), sep="/")
test.period
period.train <- paste(train.period[1], train.period[2], sep="/")
att.train <- T[period.train]$T.Adjusted
verizon.train <- VZ[period.train]$VZ.Adjusted
r.train <- att.train/verizon.train
period <- seq(min(overlap$Date), by = "5 years", length = 2)
period.train <- paste(period[1], period[2], sep="/")
test.period <- paste(period[2], max(overlap$Date), sep="/")
period.test <- paste(period[2], max(overlap$Date), sep="/")
att.test <- T[period.test]
period.test <- paste(period[2], max(overlap$Date), sep="/")
att.test <- T[period.test]$T.Adjusted
verizon.test <- VZ[period.test]$VZ.Adjusted
r.test <- att.test/verizon.test
period.test <- paste(period[2], max(overlap$Date), sep="/")
att.test <- T[period.test]$T.Adjusted
verizon.test <- VZ[period.test]$VZ.Adjusted
r.test <- att.test/verizon.test
k.max <- max((r.train - mean(r.train)) / sd(r.train))
k.max <- max((r.train - mean(r.train)) / sd(r.train))
k.min <- min((abs(r.train - mean(r.train)) / sd(r.train)))
ks <- seq(k.min, k.max, length = 1000)
m <- mean(r.train)
profits <-
sapply(ks,
function(k) {
pos <- getPositions(r.train, k)
sum(positionProfit(pos, train$ATT, train$VER,
mean(r.train)))
})
plot(ks, profits, type = "l", xlab = "k", ylab = "Profit")
ks[ profits == max(profit)]
ks[ profits == max(profits) ]
abline(v=profits)
optimal <- ks[ profits == max(profits) ]
plot(ks, profits, type = "l", xlab = "k", ylab = "Profit")
optimal <- ks[ profits == max(profits) ]
abline(v=optimal)
abline(v=optimal, alpha = .3)
abline(v=optimal, col="red")
abline(v=optimal, col="darkred")
max_profits <- profits[ optimal ]
max_profits
optimal
profits
optimal
profits
profits == optimal
max_profits <- which(profits == optimal)
max_profits
which(profits == optimal)
max_profits <- which(profits, optimal)
profits
optimal
max_profits <- which.max(profits)
max_profits
symbols(max_profits, optimal)
symbols(max_profits, optimal, circles = rep(radius, length(max_profits)))
symbols(max_profits, optimal, circles = rep(100, length(max_profits)))
max_profits
optimal
symbols(max_profits, optimal[1], circles = rep(100, length(max_profits)))
plot(ks, profits, type = "l", xlab = "k", ylab = "Profit")
symbols(max_profits, optimal[1], circles = rep(100, length(max_profits)))
symbols(max_profits, optimal[1], circles = rep(100, length(max_profits)), add = T)
plot(ks, profits, type = "l", xlab = "k", ylab = "Profit")
symbols(max_profits, optimal[1], circles = rep(100, length(max_profits)), add = T)
symbols(max_profits, optimal[1], circles = rep(100, length(max_profits)), add = T, inches = F)
max_profits
optimal[1]
ks
optimal <- ks[ profits == max(profits) ]
optimal
max_profits <- which.max(profits)
optimal <- ks[ max_profits ]
max_profits
optimal
max_profits <- which.max(profits)
optimal <- ks[ max_profits ]
optimal
symbols(optimal, optimal, circles = rep(100, length(max_profits)), add = T, inches = F)
plot(ks, profits, type = "l", xlab = "k", ylab = "Profit")
max_profits <- which.max(profits)
optimal <- ks[ max_profits ]
symbols(optimal, optimal, circles = rep(100, length(max_profits)), add = T, inches = F)
optimal
optimal
ks[198]
profits
ks
ks
profits[198]
max_profits
symbols(ks[optimal], profits[optimal],
circles = rep(100, length(max_profits)), add = T, inches = F)
ks[optimal]
optimal
symbols(ks[max_profits], profits[max_profits],
circles = rep(100, length(max_profits)), add = T, inches = F)
ks[max_profits]
profits[max_profits]
symbols(ks[max_profits], profits[max_profits],
circles = rep(100, length(max_profits)), add = T, inches = F)
radius <- 100;
radius <- 100;
symbols(ks[max_profits], profits[max_profits],
circles = rep(radius, length(max_profits)),
fg = c("darkgreen", "red"),
add = T, inches = F)
symbols(ks[max_profits], profits[max_profits],
circles = radius,
fg = c("darkgreen"),
add = T, inches = F)
ks[max_profits]
profits[max_profits]
radius
symbols(ks[max_profits], profits[max_profits],
circles = radius,
fg = "darkgreen",
add = T, inches = F)
radius <- 10;
symbols(ks[max_profits], profits[max_profits],
circles = radius,
fg = "darkgreen",
add = T, inches = F)
symbols(ks[max_profits], profits[max_profits],
circles = radius,
fg = "darkgreen",
add = T, inches = F)
tmp.k <- ks[ profits == max(profits) ]
pos <- getPositions(r.train, tmp.k[1])
all(sapply(tmp.k[-1],
function(k)
identical(pos, getPositions(r.train, k))))
tmp.k <- ks[ profits == max(profits) ]
pos <- getPositions(r.train, tmp.k[1])
all(sapply(tmp.k[-1],
function(k)
identical(pos, getPositions(r.train, k))))
k.star <- mean( ks[ profits == max(profits)])
k.star
pos <- getPositions(r.test, k.star, mean(r.train), sd(r.train))
testProfit <- sum(positionProfit(pos, test$ATT, test$VER))
testProfit
pos <- getPositions(r.test, k.star, mean(r.train), sd(r.train))
testProfit <- sum(positionProfit(pos, test$ATT, test$VER))
testProfit
r.test
k.star
mean(r.train)
sd(r.train)
pos <- getPositions(r.test, k.star, mean(r.train), sd(r.train))
pos
test
test$ATT
test$VER
positionProfit(pos, test$ATT, test$VER)
testProfit <- sum(positionProfit(pos, test$ATT, test$VER)[-1])
testProfit
positionProfit(pos, test$ATT, test$VER)[-1]
testProfit <- sum(positionProfit(pos, test$ATT, test$VER), na.rm=T)
testProfit
testProfit * 100
install.packages("blmeco")
library(blmeco, quietly = TRUE, warn.conflicts = FALSE)
data(cortbowl)
library(data.table, quietly = TRUE, warn.conflicts = FALSE)
library(dplyr, quietly = TRUE, warn.conflicts = FALSE)
library(ggthemes, quietly = TRUE, warn.conflicts = FALSE)
library(scales, quietly = TRUE, warn.conflicts = FALSE)
library(knitr, quietly = TRUE, warn.conflicts = FALSE)
library(kableExtra, quietly = TRUE, warn.conflicts = FALSE)
library(pander, quietly = TRUE, warn.conflicts = FALSE)
library(formattable, quietly = TRUE, warn.conflicts = FALSE)
library(grid, quietly = TRUE, warn.conflicts = FALSE)
library(gridExtra, quietly = TRUE, warn.conflicts = FALSE)
library(extrafont, quietly = TRUE, warn.conflicts = FALSE)
library(tinytex, quietly = TRUE, warn.conflicts = FALSE)
library(here, quietly = TRUE, warn.conflicts = FALSE)
library(lattice, quietly = TRUE, warn.conflicts = FALSE)
library(blmeco, quietly = TRUE, warn.conflicts = FALSE)
options(tinytex.verbose = TRUE)
suppressMessages(library("tidyverse"))
pretty_kable <- function(data, title, dig = 2) {
kable(data, caption = title, digits = dig) %>%
kable_styling(bootstrap_options = c("striped", "hover")) %>%
kableExtra::kable_styling(latex_options = "hold_position")
}
theme_set(theme_light())
# Theme Overrides
theme_update(axis.text.x = element_text(size = 10),
axis.text.y = element_text(size = 10),
plot.title = element_text(hjust = 0.5, size = 16, face = "bold", color = "darkgreen"),
axis.title = element_text(face = "bold", size = 12, colour = "steelblue4"),
plot.subtitle = element_text(face = "bold", size = 8, colour = "darkred"),
legend.title = element_text(size = 12, color = "darkred", face = "bold"),
legend.position = "right", legend.title.align=0.5,
panel.border = element_rect(linetype = "solid",
colour = "lightgray"),
plot.margin = unit(c( 0.1, 0.1, 0.1, 0.1), "inches"))
data(cortbow)
blmeco::cortblow
install.packages("nloptr")
blmeco::cortblow
blmeco::cortbow
data(cortblow)
library(blmeco)
