---
title: ''
mainfont: Arial
fontsize: 12pt
documentclass: report
header-includes:
- \PassOptionsToPackage{table}{xcolor}
- \usepackage{caption}
- \usepackage{amssymb}
- \usepackage{booktabs}
- \usepackage{longtable}
- \usepackage{array}
- \usepackage{multirow}
- \usepackage{wrapfig}
- \usepackage{float}
- \usepackage{colortbl}
- \usepackage{pdflscape}
- \usepackage{tabu}
- \usepackage{threeparttable}
- \usepackage{threeparttablex}
- \usepackage[normalem]{ulem}
- \usepackage{makecell}
- \usepackage[table]{xcolor}
- \usepackage{fancyhdr}
- \usepackage{boldline}
- \usepackage{tipa}
   \definecolor{headergrey}{HTML}{545454}
   \definecolor{msdblue}{HTML}{1C93D1}
   \pagestyle{fancy}
   \setlength\headheight{30pt}
   \rhead{\color{headergrey}\today}
   \fancyhead[L]{\color{headergrey}Moretz, Brandon}
   \fancyhead[C]{\Large\bfseries\color{headergrey}Cherry Blossom Race Times}
   \rfoot{\color{headergrey}Chapter 2}
   \lfoot{\color{headergrey}}
   \fancyfoot[C]{\rmfamily\color{headergrey}Case Studies In Data Science}
geometry: left = 1cm, right = 1cm, top = 2cm, bottom = 3cm
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  pdf_document:
    fig_caption: yes
    latex_engine: xelatex
editor_options: 
  chunk_output_type: console
---


```{r knitr_setup, include = FALSE}

knitr::opts_chunk$set(
   echo = T, 
   eval = TRUE, 
   dev = 'png', 
   fig.width = 9, 
   fig.height = 3.5)

options(knitr.table.format = "latex")

```

```{r report_setup, message = FALSE, warning = FALSE, include = FALSE}

library(data.table, quietly = TRUE, warn.conflicts = FALSE)
library(dplyr, quietly = TRUE, warn.conflicts = FALSE)
library(ggthemes, quietly = TRUE, warn.conflicts = FALSE)
library(scales, quietly = TRUE, warn.conflicts = FALSE)

library(knitr, quietly = TRUE, warn.conflicts = FALSE)
library(kableExtra, quietly = TRUE, warn.conflicts = FALSE)
library(pander, quietly = TRUE, warn.conflicts = FALSE)
library(formattable, quietly = TRUE, warn.conflicts = FALSE)

library(grid, quietly = TRUE, warn.conflicts = FALSE)
library(gridExtra, quietly = TRUE, warn.conflicts = FALSE)
library(extrafont, quietly = TRUE, warn.conflicts = FALSE)
library(tinytex, quietly = TRUE, warn.conflicts = FALSE)

library(here, quietly = TRUE, warn.conflicts = FALSE)

library(codetools, quietly = TRUE, warn.conflicts = FALSE)
library(lattice, quietly = TRUE, warn.conflicts = FALSE)
library(fields, quietly = TRUE, warn.conflicts = FALSE)

library(rbenchmark, quietly = TRUE, warn.conflicts = FALSE)

options(tinytex.verbose = TRUE)
suppressMessages(library("tidyverse"))

pretty_kable <- function(data, title, dig = 2) {
  kable(data, caption = title, digits = dig) %>%
    kable_styling(bootstrap_options = c("striped", "hover")) %>%
      kableExtra::kable_styling(latex_options = "hold_position")
}

theme_set(theme_light())

# Theme Overrides
theme_update(axis.text.x = element_text(size = 10),
             axis.text.y = element_text(size = 10),
             plot.title = element_text(hjust = 0.5, size = 16, face = "bold", color = "darkgreen"),
             axis.title = element_text(face = "bold", size = 12, colour = "steelblue4"),
             plot.subtitle = element_text(face = "bold", size = 8, colour = "darkred"),
             legend.title = element_text(size = 12, color = "darkred", face = "bold"),
             legend.position = "right", legend.title.align=0.5,
             panel.border = element_rect(linetype = "solid", 
                                         colour = "lightgray"), 
             plot.margin = unit(c( 0.1, 0.1, 0.1, 0.1), "inches"))

data.dir <- file.path(here::here(), "Case Studies", "datasets")

```

```{r pander_setup, include = FALSE}

knitr::opts_chunk$set(comment = NA)

panderOptions('table.alignment.default', function(df)
    ifelse(sapply(df, is.numeric), 'right', 'left'))
panderOptions('table.split.table', Inf)
panderOptions('big.mark', ",")
panderOptions('keep.trailing.zeros', TRUE)

```

# Cherry Blossom Ten Mile Run & Walk

## Examining the Impact of Age on Physical Performance

### The Raw Data

data is pre-processed from the web in \02_data.r

```{r}

read_results <- function(class, year) {
   
   folder <- ifelse(class == "men", "men_txt", "women_txt")
   file <- file.path(data.dir, folder, paste(year, ".txt", sep = ""))
   return(readLines(file))
}

```

### Race Results Preprocessing

```{r}

els <- read_results("men", 2006)

eqIndex <- grep("^===", els)
eqIndex

spacerRow <- els[eqIndex]
headerRow <- els[eqIndex - 1]
body <- els[ -(1:eqIndex) ]

headerRow <- tolower(headerRow)

timeStart <- regexpr("net", headerRow)
time <- substr(body, start = timeStart, stop = timeStart + 1)

ageStart <- regexpr("ag", headerRow)

age <- substr(body, start = ageStart, stop = ageStart + 1)
head(age)

summary(as.numeric(age))

blankLocs <- gregexpr(" ", spacerRow)
blankLocs

searchLocs <- c(0, blankLocs[[1]])

Values <- mapply(substr, list(body),
                 start = searchLocs[ -length(searchLocs)] + 1,
                 stop = searchLocs[ -1 ] - 1)

findColLocs <- function(spacerRow) {
   spaceLocs <- gregexpr(" ", spacerRow)[[1]]
   rowLength <- nchar(spacerRow)
   
   if(substring(spacerRow, rowLength, rowLength + 1) != " ")
      return(c(0, spaceLocs, rowLength + 1))
   else
      return(c(0, spaceLocs))
}

findColLocs(spacerRow)
name <- "home"
colnames <- c("name", "home", "ag", "gun", "net", "time")

colIndex <- which(colnames == name)

startPos <- regexpr(name, headerRow)[[1]]

#
# can we modify select cols to short circuit on matching w/o spaces?
#######

selectCols =
   function(colNames, headerRow, searchLocs)
   {
      sapply(colNames,
             function(name, headerRow, searchLocs)
            {
               startPos <- regexpr(name, headerRow)[[1]]
               
               if(startPos == -1)
                  return( c(NA, NA) )
               
               index <- sum(startPos >= searchLocs)
               
               c(searchLocs[index] + 1, searchLocs[index + 1])
            },
      headerRow = headerRow, searchLocs = searchLocs)
   }

searchLocs <- findColLocs(spacerRow)
loc <- selectCols("home", headerRow, searchLocs)
vars <- mapply(substr, list(body), start = loc[1,], stop = loc[2, ])

summary(as.numeric(vars))

shortColNames <- c("name", "home", "ag", "gun", "net", "time")

locCols <- selectCols(shortColNames, headerRow, searchLocs)
Values <- mapply(substr, list(body), start = locCols[1, ],
                 stop = locCols[2, ])

class(Values)

colnames(Values) = shortColNames

head(Values)
tail(Values)[, 1:3]
```

```{r}

extractVariables =
   function(file, varNames = c("name", "home", "ag", "gun", "net", "time"))
   {
      # Find the index of the row with =s
      eqIndex <- grep("^===", file)
      spacerRow <- file[eqIndex]
      headerRow <- tolower(file[ eqIndex - 1 ])
      body <- file[ -(1 : eqIndex) ]
      
      blank <- grep("^[[:blank:]]*$", body)
      footnote <- grep("^[^\\s]*[\\*]*[#]", body)
      ignore <- union(blank, footnote)
      
      if(length(ignore))
         body <- body[-ignore]
      
      # Obtain the starting and ending positions of variables
      searchLocs <- findColLocs(spacerRow)
      locCols <- selectCols(varNames, headerRow, searchLocs)
      
      Values <- mapply(substr, list(body), start = locCols[1, ],
                       stop = locCols[2, ])
      colnames(Values) <- varNames
      
      invisible(Values)
   }

load_data <- function(class) {
   folder <- ifelse(class == "men", "men_txt", "women_txt")
   filenames <- file.path(data.dir, paste(folder, "/", 1999:2012, ".txt", sep = ""))
   files <- lapply(filenames, readLines)
   names(files) <- 1999:2012
   
   mat <- lapply(files, extractVariables)
   
   return(mat)
}

```

### Data Cleaning and Reformatting Variables

```{r}
menResMat <- load_data("men"); womenResMat <- load_data("women")

length(menResMat)
sapply(menResMat, nrow)

length(womenResMat)
sapply(womenResMat, nrow)
```

Age Validation

```{r}
age <- as.numeric(menResMat[['2012']][, 'ag'])

tail(age)

age <- sapply(menResMat,
              function(x) as.numeric(x[, "ag"]))

age_values <- plyr::ldply(age, data.frame)
colnames(age_values) <- c("Year", "Age")

ggplot(age_values, aes(Age)) +
   geom_histogram(aes(fill = ..count..), bins = 30)

ggplot(age_values, aes(Year, Age)) +
   geom_boxplot(aes(fill = Year)) +
   labs(title = "Age By Race Year")
```

```{r}
sapply(age, function(x) sum(is.na(x)))

file2001 <- read_results("men", 2001)
age2001 <- as.numeric(extractVariables(file2001)[, "ag"])

badAgeIndex <- which(is.na(age2001)) + 5

file2001[badAgeIndex]

badAgeIndex

blanks <- grep("^[[:blank:]]*$", file2001)
blanks

which(age2001 < 5)

file2001[which(age2001 < 5)]


file <- read_results("men", 2001)
data <- extractVariables(file)
age <- as.numeric(data[, "ag"])

sum(age < 5)

which(age == 0)

data[which(age == 0)]

```

### Time Validation

```{r}
file2002 <- read_results("men", 2012)

charTime <- menResMat[["2012"]][, "time"]

head(charTime)
tail(charTime)

timePieces <- strsplit(charTime, ":")

timePieces[[1]]
tail(timePieces, 1)

timePieces <- sapply(timePieces, as.numeric)

runTime <- sapply(timePieces,
                  function(x) {
                     if(length(x) == 2) x[1] + x[2]/60
                     else 60 * x[1] + x[2] + x[3]/60
                  })

summary(runTime)

convertTime <- function( charTime ) {

   timePieces <- strsplit(charTime, ":")

   timePieces <- sapply(timePieces, as.numeric)

   runTime <- sapply(timePieces,
                  function(x) {
                     if(length(x) == 2) x[1] + x[2]/60
                     else 60 * x[1] + x[2] + x[3]/60
                  })
   
}

```

### Aggregate cleaning into 

```{r}
createDF =
   function(Res, year, sex) {
      useTime <- if(!is.na(Res[1, 'net']) )
                     Res[, 'net']
                  else if( !is.na(Res[1, 'gun']) )
                     Res[ , 'gun']
                  else
                     Res[, 'time']
      
      useTime <- gsub("[#\\*[:blank:]]", "", useTime)
      
      Res <- Res[ useTime != "", ]
      
      runTime <- convertTime(useTime[ useTime != "" ])
      
      N <- nrow(Res)
      
      Results <- data.frame( year = rep(year, N),
                             sex = rep(sex, N),
                             name = Res[, 'name'],
                             home = Res[, 'home'],
                             age = as.numeric(Res[, 'ag']),
                             runTime = runTime,
                             stringsAsFactors = F)
      
      invisible(Results)
   }

years <- 1999:2012
menDF <- mapply(createDF, menResMat, year = years,
                sex = rep("M", 14), SIMPLIFY = F)

warnings()[ c(1:2, 49:50)]

sapply(menDF, function(x) sum(is.na(x$runTime)))

file2006 <- read_results("men", 2006)
parsed2006 <- extractVariables(file2006)
time2006 <- parsed2006[, "net"]

```


### Further Analysis

### 1.)

Write a function that uses _read.fwf()_ to read the 28 text tables in MenTxt/ and WomenTxt/ into R. These are called 1999.text, 2000txt, etc. and are described in greater detail in 2.2. Examine the tables in a plain text editor to determine the start and end position of each column of interest (name, hometown, age and gun and net time).

Use statistics to explore the results and confirm that you have extracted the information from the correct positions in the text.

```{r}

```


### 2.)

Revise the extractVariables function (see section 2.2) to remove the rows in _menTables_ that are blank. In addition, eliminatee the rows that begin with a '*' or a '#'. You may find the following regular expression helpful for locating blank rows in a table.

_grep("^[[:blank:]]*$", body)_

The pattern uses several meta characters. The ^ is an anchor for the start of the string, the $ anchors to the end of the string, the [[:blank:]] denotes the equivalence class of any space or tab character, and * indicates that the blank character can appear 0 or more times. All together the pattern ^[[:blank:]]*\$ matches a string that contains any number of blanks from start to end.

```{r}

extractVariables =
   function(file, varNames = c("name", "home", "ag", "gun", "net", "time"))
   {
      # Find the index of the row with =s
      eqIndex <- grep("^===", file)
      spacerRow <- file[eqIndex]
      headerRow <- tolower(file[ eqIndex - 1 ])
      body <- file[ -(1 : eqIndex) ]
      
      blank <- grep("^[[:blank:]]*$", body)
      footnote <- grep("^[^\\s]*[\\*]*[#]", body)
      ignore <- union(blank, footnote)
      
      if(length(ignore))
         body <- body[-ignore]
      
      # Obtain the starting and ending positions of variables
      searchLocs <- findColLocs(spacerRow)
      locCols <- selectCols(varNames, headerRow, searchLocs)
      
      Values <- mapply(substr, list(body), start = locCols[1, ],
                       stop = locCols[2, ])
      colnames(Values) <- varNames
      
      invisible(Values)
   }

```

### 3.)

Find the record where the time is only 1.5. What happened? Determine how to handle the problem and which function needs to be modified: _extractResTable()_, _extractVariables()_, or _cleanUp()_. In your modification, include code to provide a warning message about the rows that are being dropped for having a time that is too small.

### 4.)

Examine the head and tail of the 2006 men's file. Look at both the character matrix in the list called _menResMat_ and the character vector in the list called _menFiles_ (see Sec 2.2). (Recall that the desired character matrix in _menResMat_ and the character vector in _menFiels_ both correspond to the element named "2006"). What is wrong with the hometown? Examine the header closely to figure out how this error came about. Modify the _extractVariables()_ function to fix the problem.

```{r}

```

### 5.)

Write the _convertTime()_ function described in Section 2.3. This function takes a string where time is in either the format hh:mm:ss or mm:ss. The return value is the time as numeric value of the number of minutes. Design this function to take a character vector with multiple strings and return a numeric vector.

```{r}

```

### 6.)

Modify the _createDF()_ function in Section 2.3 to handle the formatting problem with the 2006 male file. You will need to carefully inspect the raw text file in order to determien the problem.

```{r}

```

### 7.)

Follow the approach developed in Section 2.2 to read the files for the female runners and then process them using the functions in Section 2.3 to create a data frame for analysis. You may need to generalize the _createDF()_ and _extractVariables()_ functions to handle additional oddities in the raw text files.

```{r}

```

