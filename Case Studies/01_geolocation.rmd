---
title: ''
mainfont: Arial
fontsize: 12pt
documentclass: report
header-includes:
- \PassOptionsToPackage{table}{xcolor}
- \usepackage{caption}
- \usepackage{amssymb}
- \usepackage{booktabs}
- \usepackage{longtable}
- \usepackage{array}
- \usepackage{multirow}
- \usepackage{wrapfig}
- \usepackage{float}
- \usepackage{colortbl}
- \usepackage{pdflscape}
- \usepackage{tabu}
- \usepackage{threeparttable}
- \usepackage{threeparttablex}
- \usepackage[normalem]{ulem}
- \usepackage{makecell}
- \usepackage[table]{xcolor}
- \usepackage{fancyhdr}
- \usepackage{boldline}
- \usepackage{tipa}
   \definecolor{headergrey}{HTML}{545454}
   \definecolor{msdblue}{HTML}{1C93D1}
   \pagestyle{fancy}
   \setlength\headheight{30pt}
   \rhead{\color{headergrey}\today}
   \fancyhead[L]{\color{headergrey}Moretz, Brandon}
   \fancyhead[C]{\Large\bfseries\color{headergrey}Geolocation}
   \rfoot{\color{headergrey}Chapter 1}
   \lfoot{\color{headergrey}}
   \fancyfoot[C]{\rmfamily\color{headergrey}Case Studies In Data Science}
geometry: left = 1cm, right = 1cm, top = 2cm, bottom = 3cm
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  pdf_document:
    fig_caption: yes
    latex_engine: xelatex
editor_options: 
  chunk_output_type: console
---


```{r knitr_setup, include = FALSE}

knitr::opts_chunk$set(
   echo = T, 
   eval = TRUE, 
   dev = 'png', 
   fig.width = 9, 
   fig.height = 3.5)

options(knitr.table.format = "latex")

```

```{r report_setup, message = FALSE, warning = FALSE, include = FALSE}

library(data.table, quietly = TRUE, warn.conflicts = FALSE)
library(ggthemes, quietly = TRUE, warn.conflicts = FALSE)
library(scales, quietly = TRUE, warn.conflicts = FALSE)

library(knitr, quietly = TRUE, warn.conflicts = FALSE)
library(kableExtra, quietly = TRUE, warn.conflicts = FALSE)
library(pander, quietly = TRUE, warn.conflicts = FALSE)
library(formattable, quietly = TRUE, warn.conflicts = FALSE)

library(grid, quietly = TRUE, warn.conflicts = FALSE)
library(gridExtra, quietly = TRUE, warn.conflicts = FALSE)
library(extrafont, quietly = TRUE, warn.conflicts = FALSE)
library(tinytex, quietly = TRUE, warn.conflicts = FALSE)

library(here, quietly = TRUE, warn.conflicts = FALSE)

library(codetools, quietly = TRUE, warn.conflicts = FALSE)
library(lattice, quietly = TRUE, warn.conflicts = FALSE)
library(fields, quietly = TRUE, warn.conflicts = FALSE)

options(tinytex.verbose = TRUE)
suppressMessages(library("tidyverse"))

pretty_kable <- function(data, title, dig = 2) {
  kable(data, caption = title, digits = dig) %>%
    kable_styling(bootstrap_options = c("striped", "hover")) %>%
      kableExtra::kable_styling(latex_options = "hold_position")
}

theme_set(theme_light())

# Theme Overrides
theme_update(axis.text.x = element_text(size = 10),
             axis.text.y = element_text(size = 10),
             plot.title = element_text(hjust = 0.5, size = 16, face = "bold", color = "darkgreen"),
             axis.title = element_text(face = "bold", size = 12, colour = "steelblue4"),
             plot.subtitle = element_text(face = "bold", size = 8, colour = "darkred"),
             legend.title = element_text(size = 12, color = "darkred", face = "bold"),
             legend.position = "right", legend.title.align=0.5,
             panel.border = element_rect(linetype = "solid", 
                                         colour = "lightgray"), 
             plot.margin = unit(c( 0.1, 0.1, 0.1, 0.1), "inches"))

data.dir <- file.path(here::here(), "Case Studies", "datasets")

```

```{r pander_setup, include = FALSE}

knitr::opts_chunk$set(comment = NA)

panderOptions('table.alignment.default', function(df)
    ifelse(sapply(df, is.numeric), 'right', 'left'))
panderOptions('table.split.table', Inf)
panderOptions('big.mark', ",")
panderOptions('keep.trailing.zeros', TRUE)

```

# Geolocation

## Predicting Location via Indoor Positioning Systems

### The Raw Data

```{r}

file_offline <- file.path(data.dir, "offline.final.trace.txt")
file_online <- file.path(data.dir, "online.final.trace.txt")

raw_offline <- read_lines(file_offline)
raw_online <- read_lines(file_online)

```

#### Sanity Check

```{r}
# number of comment lines in the data
sum(substr(raw_offline, 1, 1) == "#")

# total number of lines in the data
length(raw_offline)
```

#### Data Pre-processing

Generate read data function for preprocessing training and test data.

```{r}

processLine <- function(x) {
   tokens <- strsplit(x, "[;=,]")[[1]]
   
   if(length(tokens) == 10)
      return(NULL)

   tmp <- matrix(tokens[ - (1:10)], ncol = 4, byrow = T)
   cbind(matrix(tokens[c(2, 4, 6:8, 10)], nrow = nrow(tmp),
                ncol = 6, byrow = T), tmp)
}

validLines <- function(data) {
   substr(data, 1, 1) != "#"
}

roundOrientation <- function(angles) {
   refs = seq(0, by = 45, length = 9)
   q <- sapply(angles, function(o) which.min(abs(o - refs)))
   c(refs[1:8], 0)[q]
}

readData <- function(file, submacs = macs) {
   
   lines <- read_lines(file)
   
   valid_lines <- lines[ validLines(lines) ]
   
   processed_lines <- lapply(valid_lines, processLine)
   
   data <- as.data.table(do.call("rbind", processed_lines),
                         stringsAsFactors = F)

   names(data) <- c("time", "scanMac", "posX", "posY", "posZ",
                       "orientation", "mac", "signal", 
                       "channel", "type")
   
   numVars <- c("time", "posX", "posY", "posZ",
                "orientation", "signal")

   data[, (numVars) := lapply(.SD, as.numeric), .SDcols = numVars]

   data <- data[ data$type == 3, ]
   data[, type := NULL]
   
   data[, rawTime := time]
   data[, time := time/1000]
   class(data$time) = c("POSIXt", "POSIXct")
   
   # drop scanMac & posZ
   data[, `:=`(scanMac = NULL, posZ = NULL)]
   
   data$angle = roundOrientation(data$orientation)
   
   data$channel = NULL
   
   data$posXY <- paste(data$posX, data$posY, sep = "-")
   
   return(data[mac %in% submacs])
}

```

#### Test Pre-processor

```{r}
lines <- processLine(raw_offline[4:20])
lines

offline_valid <- raw_offline[validLines(raw_offline)]

head(offline_valid)

length(offline_valid)
```

```{r}
tmp <- lapply(offline_valid[1:17], processLine)

sapply(tmp, nrow)
```

#### Dry Run

```{r}
offline_test <- as.data.table(do.call("rbind", tmp))

offline_test
```

#### Process

```{r}
# Enter Debug Context

# options(error = recover, warn = 2)

offline_data <- lapply(offline_valid, processLine)
offline <- as.data.table(do.call("rbind", offline_data),
                         stringsAsFactors = F)

names(offline) <- c("time", "scanMac", "posX", "posY", "posZ",
                    "orientation", "mac", "signal", 
                    "channel", "type")

numVars <- c("time", "posX", "posY", "posZ",
             "orientation", "signal")

dim(offline)

offline[, (numVars) := lapply(.SD, as.numeric), .SDcols = numVars]

offline <- offline[ offline$type == 3, ]
offline[, type := NULL]

offline[, rawTime := time]
offline[, time := time/1000]
class(offline$time) = c("POSIXt", "POSIXct")

# options(error = recover, warn = 1)
```

#### Data Cleaning

```{r}
summary(offline)
```

### Orientation Exploration

```{r}
length(unique(offline$orientation))
```

```{r, fig.height=5}
plot(ecdf(offline$orientation))
```

```{r}
ggplot(offline, aes(orientation)) +
   stat_ecdf() +
   labs("Orientation")
```

```{r}
ggplot(offline, aes(orientation, fill = ..count..)) +
   geom_histogram(bins = 30) +
   scale_y_continuous(labels = comma) +
   labs("Orientation Value Clusters")
```

```{r}

offline$angle <- roundOrientation(offline$orientation)

# angle = cleaned orientation column
ggplot(offline, aes(angle)) +
   stat_ecdf()

ggplot(offline, aes(angle, fill = ..count..)) +
   geom_histogram(bins = 30) +
   scale_y_continuous(labels = comma) +
   labs("Cleaned Up Angles")
```

```{r}
with(offline, boxplot(orientation ~ angle,
                      xlab = "nearest 45 degree angle",
                      ylab = "orientation"))

ggplot(offline, aes(angle, orientation, group = angle)) +
   geom_boxplot() +
   labs(title = "Cleaned Angle vs Raw Orientation", 
        x = "nearest 45 degree angle", 
        y = "orientation")
```

### MAC Address

```{r}
c(length(unique(offline$mac)), length(unique(offline$channel)))

table(offline$mac)

ggplot(offline, aes(mac, fill = ..count..)) +
   geom_histogram(stat = "count", bins = 30) +
   scale_y_continuous(labels = comma)

# keep only the top 7 MAC address data points

dim(offline)

offline_macs <- names(sort(table(offline$mac), decreasing = T)[1:7])

dim(offline)
```

```{r}
macChannel <- with(offline, table(mac, channel))
apply(macChannel, 1, function(x) sum(x > 0))

# mac and channel are 1:1, we can remove channel
#offline$channel := NULL
```

### Exploring the Position of the Hand-Held Device

```{r}
locDF <- with(offline,
              by(offline, list(posX, posY), function(x) x))

length(locDF)

sum(sapply(locDF, is.null))

locDF <- locDF[ !sapply(locDF, is.null)]

length(locDF)

locCounts <- sapply(locDF, nrow)

locCounts <- sapply(locDF,
                    function(df)
                       c(df[1, c("posX", "posY")], count = nrow(df)))

class(locCounts)

dim(locCounts)

locCounts[ , 1:8]

locCountsDF <- as.data.table(t(locCounts))

locCountsDF$posX <- unlist(locCountsDF$posX)
locCountsDF$posY <- unlist(locCountsDF$posY)

ggplot(locCountsDF, aes(posX, posY, label = count)) +
   geom_text(angle = 45) +
   labs(title = "X / Y postion counts")
```

### Final Data Prep

```{r}
offline <- readData(file_offline, offline_macs)
```

#### Signal Strength

```{r, fig.height=7}
bwplot(signal ~ factor(angle) | mac, data = offline,
       subset = posX == 2 & posY == 12 & 
          mac != "00:0f:a3:39:dd:cd",
       layout = c(2, 3))

summary(offline$signal)
```

```{r, fig.height=7}
densityplot(~ signal | mac + factor(angle), data = offline,
            subset = posX == 24 & posY == 4 &
               mac != "00:0f:a3:39:dd:cd",
            bw = 0.5, plot.points = F)
```

```{r, fig.width=5}
byLocAngleAP <- with(offline,
                     by(offline, list(posXY, angle, mac),
                        function(x) x))
signalSummary <-
   lapply(byLocAngleAP,
          function(oneLoc) {
             ans = oneLoc[1, ]
             ans$medSignal = median(oneLoc$signal)
             ans$avgSignal = mean(oneLoc$signal)
             ans$num = length(oneLoc$signal)
             ans$sdSignal = sd(oneLoc$signal)
             ans$iqrSignal = IQR(oneLoc$signal)
             ans
          })

offlineSummary <- do.call("rbind", signalSummary)

breaks <- seq(-90, -30, by = 5)

bwplot(sdSignal ~ cut(avgSignal, breaks = breaks),
       data = offlineSummary,
       subset = mac != "00:0f:a3:39:dd:cd",
       xlab = "Mean Signal", ylab = "SD Signal")
```

```{r}
with(offlineSummary,
     smoothScatter((avgSignal - medSignal) ~ num,
                   xlab = "Number of Observations",
                   ylab = "mean - median"))
abline(h = 0, col = "#984ea3", lwd = 2)

lo.obj <- with(offlineSummary,
               loess(diff ~ num,
                     data = data.frame(diff = (avgSignal - medSignal),
                                       num = num)))

lo.obj.pr <- predict(lo.obj, newdata = data.frame(num = (70:120)))
lines(x = 70:120, y = lo.obj.pr, col = "#4daf4a", lwd = 2)
```

#### Signal and Distance

```{r, fig.height=6}

subMacs <- names(sort(table(offline$mac), decreasing = T))[1:7]

surfaceSS <- function(data, mac, angle) {
   oneAPAngle <- subset(offlineSummary, mac == mac & angle == angle)   

   smothSS <- Tps(oneAPAngle[, c("posX", "posY")],
                  oneAPAngle$avgSignal)
   
   vizSmooth <- predictSurface(smothSS)
   
   plot.surface(vizSmooth, type = "C")
   points(oneAPAngle$posX, oneAPAngle$posY, pch=19, cex = 0.5)
}

surfaceSS(offlineSummary, subMacs[5], 0)
```

```{r, fig.height = 7}
parCur <- par(mfrow = c(2,2), mar = rep(1, 4))
mapply(surfaceSS, mac = subMacs[ rep(c(5, 1), each = 2)],
       data = list(data = offlineSummary))
par(parCur)
```

Exclude one of two similar access points

```{r}
offlineSummary <- subset(offlineSummary, mac != subMacs[2])
```

```{r}
AP <- matrix( c( 7.5, 6.3, 2.5, -.8, 12.8, -2.8,
                 1, 14, 33.5, 9.3, 33.5, 2.8),
              ncol = 2, byrow = T,
              dimnames = list(subMacs[ -2 ], c("x", "y") ))

ggplot(data.table(mac = rownames(AP), AP), aes(x, y)) +
   geom_point()
```

```{r, fig.height=7}
diffs <- offlineSummary[, c("posX", "posY")] - AP[offlineSummary$mac, ]

offlineSummary$dist <- sqrt(diffs[, 1]^2 + diffs[, 2]^2)

xyplot(signal ~ dist | factor(mac) + factor(angle),
       data = offlineSummary, pch = 19, cex = 0.3,
       xlab = "distance")
```

### Nearest Neighbor Methods to Predict Location

```{r}
macs <- unique(offlineSummary$mac)

online <- readData(file_online, submacs = macs)

length(unique(online$posXY))
```

```{r}
tabonlineXYA = table(online$posXY, online$angle)
tabonlineXYA[1:6, ]
```

```{r}
keepVars <- c("posXY", "posX", "posY", "orientation", "angle")

byLoc <- with(online,
              by(online, list(posXY),
                 function(x) {
                    ans <- x[1, ..keepVars]
                    avgSS <- tapply(x$signal, x$mac, mean)
                    y = matrix(avgSS, nrow = 1, ncol = 6,
                               dimnames = list(ans$posXY, names(avgSS)))
                    cbind(ans, y)
                 }))

onlineSummary <- do.call("rbind", byLoc)

dim(onlineSummary)

names(onlineSummary)
```

#### Choice of Orientation

```{r}

reshapeSS <- function(data, 
                      varSignal = "signal",
                      keepVars = c("posXY", "posX", "posY"),
                      sampleAngle = F) {
   
   if(sampleAngle)
      data <- data[angle == sample(data$angle, size = 1), ]
   
   byLocation <- with(data,
                 by(data, list(posXY),
                    function(x) {
                       ans <- x[1, ..keepVars]
                       avgSS <- tapply(x$signal, x$mac, mean)
                       y = matrix(avgSS, nrow = 1, dimnames = list(ans$posXY, names(avgSS)))
                       cbind(ans, y)
                    }))
   
   newDataSS <- do.call("rbind", byLocation)
   
   col_names <- colnames(newDataSS)
   to_change <- !(col_names %in% keepVars)
   
   n_cols <- length(col_names)
   start <- length(keepVars)
   
   colnames(newDataSS)[to_change] <- sapply(col_names[to_change], function(col) {
      n <- nchar(col)
      substr(col, n - 2, n)
   })
   
   newDataSS[, start:ncol(newDataSS)] <- round(newDataSS[, start:ncol(newDataSS)])
   
   return(newDataSS)
}

selectTrain <- function(angleNewObs, signals, m) {
   
   refs <- seq(0, by = 45, length = 8)
   
   nearestAngle <- roundOrientation(angleNewObs)
   
   if( m %% 2 == 1) {
      angles <- seq(-45 * (m - 1) / 2, 45 * (m - 1) / 2, length = m)
   } else {
      m = m + 1
      angles <- seq(-45 * (m - 1) / 2, 45 * (m - 1) / 2, length = m)
      
      if( sign(angleNewObs - nearestAngle) >= 1)
         angles = angles[ -1 ]
      else
         angles = angles[ -m ]
   }
   
   angles <- angles + nearestAngle
   angles[angles < 0] = angles[ angles < 0] + 360
   angles[angles > 360] = angles[ angles > 360 ] - 360
   
   signals <- signals[angle %in% angles, ]

   reshapeSS(signals, varSignal = "avgSignal")
}

train130 <- selectTrain(130, offlineSummary, m = 3)

dim(train130)

findNN <- function(newSignal, trainSubset) {
   diffs <- apply(trainSubset[ , 4:9], 1,
                  function(x) x - newSignal)
   dists <- apply(diffs, 2, function(x) sqrt(sum(x^2)) )
   closest <- order(dists)
   return(trainSubset[closest, 1:3 ])
}

predXY <- function(newSignals, newAngles, trainData,
                   numAngles = 1, k = 3) {
   
   closeXY <- list(length = nrow(newSignals))
   
   for(i in 1:nrow(newSignals)) {
      trainSS <- selectTrain(newAngles[i], trainData, m = numAngles)
      closeXY[[i]] = 
         findNN(newSignal = as.numeric(newSignals[i, ]), trainSS)
   }
   
   estXY = lapply(closeXY,
                  function(x) sapply(x[, 2:3],
                                     function(x) mean(x[1:k])))
   
   estXY <- do.call("rbind", estXY)
   
   return(estXY)
}

estXYk1 <- predXY(newSignals = onlineSummary[, 6:11],
                  newAngles = onlineSummary[, 4],
                  offlineSummary, numAngles = 3, k = 1)

estXYk3 <- predXY(newSignals = onlineSummary[, 6:11],
                  newAngles = onlineSummary[, 4],
                  offlineSummary, numAngles = 3, k = 3)
```

```{r}
calcError <- function(estXY, actualXY)
   sum( rowSums( (estXY - actualXY) ^ 2) )

actualXY <- onlineSummary[, c("posX", "posY")]
sapply(list(estXYk1, estXYk3), calcError, actualXY)

```

```{r}
v <- 11;

permuteLocs <- sample(unique(offlineSummary$posXY))
permuteLocs <- matrix(permuteLocs, ncol = v,
                      nrow = floor(length(permuteLocs)/v))

```

```{r}
onlineFold <- subset(offlineSummary, posXY %in% permuteLocs[, 1])

onlineCVSummary <- reshapeSS(offline, 
                              keepVars = c("posXY", "posX", "posY", "angle"),
                              sampleAngle = T)

onlineFold <- subset(onlineCVSummary,
                     posXY %in% permuteLocs[ , 1])

estFold <- predXY(newSignals = onlineFold[, 6:11],
                  newAngles = onlineFold[, 4],
                  offlineFold, numAngles = 3, k = 3)

actualFold <- onlineFold[, c("posX", "posY")]
calcError(estFold, actualFold)

```

```{r}
K <- 20
err <- rep(0, K)

for(j in 1:v) {
   onlineFold <- subset(onlineCVSummary,
                        posXY %in% permuteLocs[, j])
   offlineFold <- subset(offlineSummary,
                         posXY %in% permuteLocs[ , -j])
   
   actualFold <- onlineFold[, c("posX", "posY")]
   
   for(k in 1:K) {
      estFold <- predXY(newSignals = onlineFold[, 6:11],
                        newAngles = onlineFold[, 4],
                        offlineFold, numAngles = 3, k = k)
      
      err[k] <- err[k] + calcError(estFold, actualFold) 
   }
}


```


```{r}
k_values <- data.table(K = 1:K, Error = err, Min = which.min(err))

ggplot(k_values, aes(K, Error)) +
   geom_line(aes(col = Error)) +
   geom_hline(data = k_values[K == Min], aes(yintercept = Error), col = "darkblue") +
   labs("K-NN Training Error")
```

```{r}
estXYk5 <- predXY(newSignals = onlineSummary[, 6:11],
                 newAngles = onlineSummary[, 4],
                 offlineSummary, numAngles = 3, k = 5)
```

```{r}
calcError(estXYk5, actualXY)
```

```{r}
error_table <- data.table(K = c(1, 3, 5), 
                          Error = c(calcError(estXYk1, actualXY), 
                                    calcError(estXYk3, actualXY), 
                                    calcError(estXYk5, actualXY)))

ggplot(error_table, aes(K, Error, fill = -Error)) +
   geom_bar(stat = "identity")
```

```{r}
predXY <- function(newSignals, newAngles, trainData, numAngles = 1, k = 3) {
   chooseXY <- list(length = nrow(newSignals))
   
   for(i in 1:nrow(newSignals)) {
      trainSS <- selectTrain(newangles[i], trainData, m = numAngles)
      closeXY[[i]] <- findNN(newSignal = as.numeric(newSignals[i, ]),
                             trainSS)
   }
   
   estXY <- lapply(closeXY, function(x)
                              sapply(x[, 2:3],
                                     function(x) mean(x[1:k])))
   estXY <- do.call("rbind", estXY)
   
   return(XY)
}

```

### Follow-up

Write the code to read the raw training data into the data structure in the first approach described in section 1.2. That is, the data structure is a data frame with a column for each MAC address that detected a signal. For the column name, use the last two characters of the MAC address, or some other unique identifier.

```{r}

```

